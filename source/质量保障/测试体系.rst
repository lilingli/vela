=========
测试体系
=========

Bug
====

定义和判断标准
--------------

与最终用户期望的行为不一致的系统行为被称为Bug。

.. todo:: wiki

系统的期望行为一般是由产品规格(Product Specification, a.k.a Spec)，所以一般测试的标准也是比较系统的实际行为和产品规格中的描述，找出不一致的部分，作为Bug记录转交给相关项目成员进行修正。然而，由于产品规格是项目组负责产品分析的人员，根据自己对于最终用户和实际使用场景的理解，设计和编写的，所以产品规格本身可能存在局限或者误差甚至错误。基于这个原因，产品规格并不是判断Bug的唯一标准。进一步的，产品规格本身也需要质量保证。

当以下五条标准中任何一条成立的时候，系统就存在Bug：

    #. 系统没有实现产品说明中定义的行为。
    #. 系统实现了产品说明中不允许出现的行为。
    #. 系统实现了产品说明中没有明确列出的行为。
    #. 系统没有实现产品说明中没有明确列出，但是应当实现的行为。

系统难以理解或者使用，性能过低等，从最终用户的角度来说不能接受的任何情况。

综合来说，实际操作中，判断标准首先是产品规格或者团队对于产品功能的共识。当出现产品说明中没有明确定义的情况，或者产品说明存在疑点的时候，就需要以最终用户和最终运用场景作为根本的判断标准。

Bug的产生和影响
--------------

一个软件项目的功能定义、技术设计、开发以及部署的各个阶段都有可能产生Bug。根据产生Bug数量从多到少来排序，最多的三个阶段是功能定义、技术设计和开发。其中，很多在开发阶段发现的Bug，根据根本原因来分析，其实都是产生在功能定义和技术设计阶段。从原因来分析，最多的Bug是由于沟通和理解不准确导致的。比如，负责产品定义的人员对于最终用户的功能需求和业务场景的理解不够完整和准确，设计人员对于产品规格中的描述的理解出现偏差，甚至多个开发人员之间的沟通出现问题。

由于项目前一阶段出现的问题，会在后续阶段产生更多的问题。越到后期阶段，修复这些问题的成本越高，而带来的损失越大。综合来考虑，同一个Bug的造成的损失，会随着项目周期的推进，成指数增长。

所以对于QA人员来说，从项目的计划阶段就需要参与进来，保障项目整个生命周期各个阶段工作和产出物的质量，及早发现可能的问题。

QA工程师的职责
=============

QA工程师除了和测试工程师一样，需要通过各种手段发现产品中间和最终产出物的Bug。此外，QA工程师还需要针对项目的业务和技术特点，以及团队的工作方式方法，尽早预测和预防可能出现的问题，并且对于已经发现的问题，改进技术和流程手段，避免和减少同类问题的出现。

所以，一个优秀的QA工程师需要以下能力：

    #. 对于系统业务场景和业务知识有深入和完整的理解，并且能够从最终用户的角度思考
        如上文所述，判断系统是否有Bug的根本标准是系统是否能够满足最终用户的需求，解决最终用户的业务问题，所以QA工程师必须要对于最终业务场景和相关业务知识有完整深刻的理解。并且，需要以最终用户的角度，以他们的知识技能背景和使用习惯，以及使用过程中可能出现的问题的角度，来分析系统。
    #. 对于系统的技术设计和实现有深入和完整的理解
        最终用户的需求的实现，是需要通过技术手段来达成的。那么，技术解决方案是否能够完整充分的满足需求，存在的限制条件，可能存在的问题，测试方案的设计，测试结果的可靠性等，都需要QA工程师运用自己的技术知识来分析和改进。
    #. 对于问题深入分析的态度和能力
        当系统的某一个行为与期望不一致的时候，多数时候都是一个更深层次的问题在这个场景或者条件下的一个表现。这个问题很可能会在其他场景或者条件下以另一种形式表现出来。如果只是通过简单的查看尽可能多的功能或者场景，来发现尽可能多的问题，这种手段的效率是非常低下的。而且，由于条件组合的复杂度，以及某些条件达到的难度，会导致一些问题完全无法被发现。所以，对于已经发现的问题，需要深入分析其根本原因，以及可能的影响，对针对性的设计测试方案，并分析解决方案的有效性。
        同样，对于问题的深入分析，也需要对于系统的技术知识有深入的理解，同时，分析的过程也是对于系统技术加深学习和理解的过程。
    #. 高效准确的沟通能力
        如上文所述，系统Bug最大的产生原因就是由于团队人员间的沟通导致的。所以，QA工程师必须要良好的沟通能力，保证沟通的有效性和可靠性。
        这里的沟通能力包括两个方面：
        #. 准确的接受和理解他人所输入的信息。要达到这一点，需要将接受到的信息进行分析和消化，敏感的发现信息中的疑点，比如可能的歧义，隐含的上下文，背景知识的欠缺等，并及时有效的确认。
        #. 准确的表达能力。同样，需要将需要表达的信息可能的问题主动进行分析，确认没有表达的歧义、不明确的上下文、对方缺少的背景知识等，并及时要求对方给出必要的反馈和确认。

测试工作公理
===========

不可能完全测试一个程序
-------------------

一个系统的输入参数和可能受到的影响的种类非常多，就算是最简单的软件也是如此。而不同参数和影响之间的组合则是以指数级增长的。而完全测试一个程度意味着需要将所有组合进行验证，而这是不可能完成的，无论从理论上来说，还是从实际操作上来说。

软件测试是基于风险分析的
--------------------

由于不可能完全测试一个程序，所以不可能保证所有的Bug都会被发现。而另一方面，发现Bug的成本是随着Bug发现的数量增长的，但在实际工作中，测试资源是有限的。因而，制定测试计划和方案的时候，必然要对测试内容有所取舍。合理的取舍需要综合考虑漏测Bug的风险成本和可用的测试资源，让两者达到一个合理的交点。

通常，测试成本相对是比较容易评估的，而测试方案的风险，也就是在对于潜在的Bug造成的损失的风险的评估，需要扎实的技术和业务知识以及经验，所以是测试方案的关键点和难点。

测试不能保证Bug不存在
-------------------

同样由于完全测试的不可能性，所以测试不可能覆盖所有的情况。那么，当没有Bug被发现的时候，有可能是的确没有Bug，但也有可能是测试用例的覆盖不够。通常，由于实际系统的复杂性和设计的不完备性，测试覆盖不完全而导致Bug没有被发现的情况更加常见。这种现实再次要求QA工程师对于测试方案和测试结果有严肃和正确的认识。

发现的Bug越多，未发现的Bug也越多
-----------------------------

这条公理的意思是Bug的出现经常会有聚集现象，也就是在某一段时间或者系统的某些关联功能上，当有Bug被发现的时候，很可能会有类似或者相关的Bug被发现。

出现这种情况的原因一般是由于开发人员经常会重复犯同样的错误，以及同一个深层次的问题在最外层的系统行为上表现为多个相关的Bug。所以，当一个Bug被发现的时候，对于这个Bug的产生原因必须要深入分析，并基于分析结果对测试方案进行必要的调整，更加有效和高效的发现系统的Bug。

杀虫剂悖论
----------

当同一型的Bug被发现并修复之后，一般同类型的Bug再出现的可能性就会降低。那么，对于相关方面投入的测试资源的产出就会下降。这种情况被称为杀虫剂悖论。

这种情况可以被理解为系统质量以及研发团队的开发工作质量有提高，而相关系统相关方面可能会出现问题的风险降低了。不过，这也并不意味着不需要对于相关部分进行进一步的测试，而是可以调整测试方案中相关风险权重。

不是所有发现的Bug都会被修复
-------------------------

类似于测试方案的投入产出考虑，Bug修复工作也需要考虑投入和产出。一般，需要考虑的是Bug的严重程度和优先级，修复Bug所需要的资源，以及修复Bug的风险。Bug的严重程度就是Bug对于系统运行的影响程度，比如是否会导致某个功能完全不可用，还是只是使用上会有不便。优先级除了受严重程度的影响以外，还会受到Bug所影响的功能的业务重要性的影响，比如一个导致一年只会使用一两次的功能不可用的Bug的优先级并不一定会比一个导致一个每天被使用10次的功能性能下降10%的Bug的优先级高。修复Bug所需要的资源主要指修复这个Bug所需要的研发人员和工作时间，以及验证Bug修复所需要的测试人员和时间。更重要的是修复Bug的风险。因为修复Bug肯定会对系统产生影响，甚至导致原来正常的功能出现问题，所以Bug的修复方案的影响以及风险也必须严肃分析。比如，一个可用性Bug的修复如果有可能会导致核心功能失常，往往会选择不修复。

基本术语
=========

精确性(Precision)和准确性(Accuracy)
---------------------------------

系统的精确性和准确性是用于描述系统行为的结果和期望结果之间的差异的。精确性是指系统多个结果之间的距离分布情况，而准确性是指实际结果和期望结果之间差距。比如，一个浮点点计算器，在计算10.0 / 2.0时给出的三次的结果，分别是4.1、4.2、5.7时，精确性和准确性都比较差。如果是5.7、5.4、5.6，则精确性较高，但准确性很差。如果是4.7、5.2、5.3，则准确性较好，精确性则不高。4.9、4.8、5.1的结果，相对来说精确性和准确性都比较好。

检验(Verification)和核实(Validation)
-----------------------------------

检验指比较系统行为和产品规格的区别，核实是指比较系统行为和用户需求之间的区别。产品规格来自于用户需求，但由于可能的沟通理解问题，以及产品规格本身的错误，会导致产品规模并不一定能真实反映需求，所以系统应该以需求核实为根本。

质量(Quality)和可靠性(Reliability)
---------------------------------
质量意味着系统的行为是否能够满足用户的期望。可靠意味着系统的行为总是稳定的和可预期的。可靠的系统并不一定是高质量的，因为一个稳定的但是不能满足用户需求的系统的质量也是不高的。而可靠性是质量的一部分，一个不可靠的系统肯定不是高质量的系统。

测试(Testing)和质量保障(Quality Assurance)
-----------------------------------------

测试的目的是尽早的发现系统中的问题，而质量保障的目标是通过分析系统的开发流程和手段，以及之前发现的问题，改进工作的流程和方法，以预防问题的出现。

测试类型
========

测试的类型划分方式有很多，基本根据测试方式和被测试的系统状态两个维度，可以把测试分为黑盒测试和白盒测试，以及静态测试和动态测试。这两个维度可以相互组合成四种测试类型：

+----------+--------------+----------------------------+
|          | 黑盒测试     | 白盒测试                   |
+==========+==============+============================+
| 静态测试 | 产品规格测试 | 静态代码检测               |
+----------+--------------+----------------------------+
| 动态测试 | 行为测试     | 单元测试/集成测试/系统测试 |
+----------+--------------+----------------------------+

黑盒测试(Black-Box Testing)和白盒测试(White-Box Testing)
--------------------------------------------------------

当测试人员完全不了解系统的技术设计和实现，而只有系统的输入和输出信息的情况下进行的测试，被称为黑盒测试。一般这种测试主要以系统的业务功能验证为主。

如果测试人员能够了解系统的所有内部技术设计和实现，并且以此为基础，调整和改进测试方案和工具，在这种情况下进行的测试被称为白盒测试。这种测试除了关注业务功能的实现情况以外，往往还会关注系统的技术指标，比如性能和稳定性等。

在实际工作中，一般不会有完全的黑盒测试或者白盒测试，而是介于两者之间。而一般以哪种成分占优，或者倾向于功能还是技术指标的验证来区别是黑盒还是白盒测试。如果两种成分相差不多，这种测试也被称为灰盒测试。

静态测试(Static Testing)和动态测试(Dynamic Testing)
---------------------------------------------------

在运行状态的系统上进行的测试被称为动态测试，而不需要系统运行进行的测试被称为静态测试。

静态黑盒测试(产品规格测试)
-------------------------

静态黑盒测试主要是指对于产品规格的测试。产品规格(Product Specification)来自于用户需求，然后将其转变成为系统功能的具体描述。在这个过程中出现的沟通理解差异，以及表达方式的错误，都有可能导致产品规格本身不能准确的反映最终的用户需求。这就需要对产品规格本身进行测试。由于这种测试集中在对于系统需求上，而技术设计和实现信息并不一定是必需的，同时也不可能运行系统，所以是静态黑盒测试。

在验证产品规格文档的时候，除了良好的业务知识以外，也可以通过以下方面来发现潜在的问题：

    - 完整性
    - 准确性
    - 精确、无歧义、清晰
    - 一致性
    - 相关性
    - 可行性
    - 代码无关
    - 可测试

同时，在检验文档的时候，除了业务功能以外，还需要考虑以下方面，以及这些方面对于测试的支持：

    - 期望的规模大小
    - 复杂程度
    - 可测性
    - 可靠性要求
    - 安全性要求

动态黑盒测试(行为测试)
=====================

在没有详细的系统内部实现细节情况，而只能通过验证在特定输入或者操作下系统行为是否与预期行为一致的测试，这种测试就是动态黑盒测试，也就是行为测试(Behavior Testing)。在设计这种类型的测试方案的时候，测试用例的输入和运行环境是考虑的重点。而系统在特定场景下的期望行为，则是测试用例是否通过的基本标准。

通过性测试(Test-to-Pass)和失效性测试(Test-to-Fail)
-----------------------------------------------------

通过性测试是指在系统状态和行为必然为正常情况下的测试。通过这种测试来验证系统的基本功能是否正常。

失效性测试是指系统运行在预期内的或者预期外的异常条件或者极限条件下的测试。失效性测试用来检验系统对于异常情况的处理行为和风险，以及找出系统运行的性能、容量等类型的边界。

等价划分(Equivalence Partitioning)
-------------------------------------

如上文所述，是不可能对一个系统进行完全的测试的。那么，在有限的测试资源的条件下，就可以使用等价划分来简单测试用例。等价划分是基于系统的输入参数及其组合之间的业务特性，在尽量保证测试方案风险不变或者可控的前提下，将相同性质的测试用例进行精简的过程。

等价划分首先要考虑数据测试。比如一个输入参数为所有自然数的系统，不一定需要，当然也不可能验证所有从1到正无穷大的所有输入可能，而只需要选择1、5、100等有限的几个。当然，对于测试用例的精简和选择，除了基于业务特性，往往也需要对于系统的技术实现有所了解。比如对于自然数来说，65535作为计算机32整型数据的上限可能也是一个需要考虑的值。

边界条件和子边界条件有关，但两者并不完全等价，因为等价划分除了关注数据的边界条件以外，也需要关注非边界的输入。

对于有状态的系统，除了考虑数据测试，等价划分也必须考虑状态测试。对于同一组输入数据，在不同的系统状态下，系统的行为是否是等价的。如果是等价的，一般来说不同状态下的测试用例是可以合并精简的。需要注意的是，两个测试用例下系统的行为输出相同并不意味着两个测试用例是等价的。一般，还需要考虑系统的状态变化。

数据测试(Data Testing)
------------------------

对于一个系统行为会直接产生影响的，有两个方面：输入数据和内部状态。

    .. todo:: 系统影响因素的类型划分

对于输入数据，需要考虑以下几种重要的类型：

边界条件(Boundary Condition)
`````````````````````````````

边界条件是系统正常运行的极值。对于直接影响系统运行的数据，边界条件应该是系统正常运行和异常的分界线。所以，边界条件也是设计测试方案的重要依据。完整的边界条件测试应该同时包括边界两边最接近边界的两个极限值，如对一个接受自然数输入的系统，需要1和0两个值分别做为边界条件测试的数据。使用这两个值的边界条件测试分别属于通过性测试和失效性测试。

需要注意的是，这里所说的边界条件主要是指业务的边界条件，而技术实现产生的边界条件应当和业务边界一致。

    .. todo:: 对于内部业务逻辑变化的边界是否属于边界条件

子边界条件(Sub-Boundary Condition)
````````````````````````````````

子边界条是由于技术实现或者技术限制导致的内部边界条件。这种边界条件一般出现在技术实现能够处理的数据范围小于业务逻辑所要处理的数据范围的情况下。比如，对于一个要处理所有自然数的系统来说，32位整型数据能够处理的上限65535、以及超过个范围的65536应当做为可能的子边界条件考虑。

由于系统必须尽可能的处理业务需求范围内的所有数据，那么一般会对于内部边界两边的数据采用不同的技术实现。这样，系统的最终行为表现上来说，这种内部边界对于最终用户是透明的。但是，从测试的角度来说，如果不能覆盖内部边界内外的情况，就会有漏测问题的可能，所以对于子边界条件，测试方案也必须覆盖。只是这种内部边界相关的测试都属于通过性测试。

子边界条件由于和内部技术实际紧密相关，往往也可以算在白盒测试或者盒测试的范畴。

默认值，空字符串，零值，空值(Default, Empty, Blank, Zero, None, Null)
``````````````````````````````````````````````````````````````````

默认值(Default)是指在用户没有明确指定输入参数的时候，系统自动使用的参数值。默认值的挑选以及处理使用经常会被忽略，所以需要在测试的时候专门考虑。

空字符串(Blank)是一种特殊的字符输入值，包括长度为0的字符串，或者只包含空格(Space)、制表符(tab)、换行符(new line, \n)，或者回国符(carriage return, \r)这类空白字符的字符串。对于需要根据字符串内容进行条件判断或者操作的代码，空字符串通常是应当和空值(None, Null)做为相同的情况处理。但这种情况经常会被忽略，所以需要在测试的时候专门考虑。类似的，对于字符串开头和结尾有空白字符的字符串输入，也需要专门考虑。

零值(Zero, 0)作为正整数和负整数的分界，以及正浮点数和负浮点数的分界，经常会成为边界条件或者子边界条件。另外，零值也经常被拿来作为一个特殊的标志值，用于条件判断。所以，零值需要在设计测试用例的时候重点考虑。

空值(Null, None)是很多程序语言的特殊值，表示一个指针或者引用没有指向一个可用的对象或者内存地址。系统的内部或者外部接口如果没有很好的处理可能传入的空值，经常会导致不可预测的系统异常。另外，由于空值的特殊类，类似于零值，空值也经常会被拿来做为特殊的标志值。所以对于空值，设计测试用例的时候需要重点考虑。由于人工操作不能直接给系统输入空值，一般直接使用空值的测试属于自动化测试。

错误数据，垃圾数据
`````````````````

为了进行失效性测试，对系统输入的任何正常业务可处理的数据之外的数据，都可以认为是这类数据。比如一个包含$符号的字符串作为电话号码输入。

状态测试(State Testing)
------------------------

很多系统的行为，除了受到输入数据的影响，还会受到系统内部状态的影响。这种内部状态也经常被称为上下文(context)。比如，对于一个网上商城系统，一次下单操作的结果除了和当前操作的数据，比如货物品种和数量有关以外，还和目前的库存有关。商品的库存数量就是一个状态，也就是上下文。对于这种行为结果受到状态或者上下文影响的系统，也被称为有状态系统(Stateful System)。

对于这种系统的测试，在设计测试方案和用例的时候，除了要考虑输入数据以外，还需要考虑需要的状态以及状态的准备方法。另一方面，有状态系统的内部状态也会随着操作和输入数据而发生变化，所以在校验测试结果的时候，除了要比较操作的直接输出以外，还需要确认系统状态的变化。

综上，对于有状态系统的测试，用例的条件是输入数据和系统状态的组合，而结果校验需要包括操作结果和系统状态变化。为了覆盖所有可能的系统行为，理论上任意两个状态之间的迁移都需要测试，而实际上是不可能达到的。对于状态测试的简化，见下文逻辑流测试部分。

注意，系统状态在不同的上下文里会有两种意思。狭义的系统状态指若干专门用来明确表示系统或者模块当前状态的字段，这种字段的值往往是一系列预定义的枚举值。广义的系统状态可以包括所有的系统内部数据，包括持久化和不持久化的数据。

逻辑流测试(Testing the Logic Flow)
```````````````````````````````````

对于一个实际系统，其内部状态是有限的。系统会在不同的操作以及相关输入下，在不同的状态之间迁移。这些操作和对应的输入，被称为状态迁移路径(path)。系统的有限状态，以及相互迁移的路径，共同组成了系统的逻辑流(Logic Flow)。状态测试的核心方法就是基于逻辑流的测试。

分析系统的逻辑流的重要工具是状态迁移表(State Transition Table)和状态图(State Diagram)。这两个工具的具体信息参考State Transition Table和State Diagram，这里不再展开。

理论上，状态测试需要任意两个状态之间的路径，而实际操作中是不可能实现的，所以也需要进行等价类精简。一般，可以通过以下具体手段来进行：

    - 每个状态至少要覆盖一次
    - 直接连接两个状态的路径至少要覆盖一次
    - 最常见的状态迁移
    - 所有错误状态的进和出
这里讨论的状态主要指狭义的系统状态。

状态失效性测试(Testing States to Fail)
`````````````````````````````````````

任何有状态系统，其状态都有可能出现修改错误、保存资源不足等问题。对于这类情况的测试，属于状态失效性测试。这类测试对于系统长期稳定的运行十分关键。

竞争条件(Race Condition)
'''''''''''''''''''''''''

实际项目中的系统通常都是支持并发操作的，那么也就意味着对于系统内部状态的访问和修改是并发的。当系统内部状态的并发访问控制有疏漏的时候，会导致状态污染(corruption)，进而导致系统行为异常。

由竞争条件导致的Bug往往表现的比较随机，并且需要一定程度以上的系统压力下才有可能在有限的测试时间内被观测到。当单个错误被发现的时候，原因分析也会很困难。为了提高这类问题被及时发现的机率，必须对于系统会并发修改的状态进行整理分析。针对这些状态的业务意义和并发访问的技术特点，设计专门的测试用例，并使用测试工具提供足够的和持续的系统压力。

负载测试(Load Testing)和压力测试(Stress Testing)
````````````````````````````````````````````````

系统在长时间或者一定负载情况下，可能会出现在普通测试中不能发现的问题。比如系统资源泄漏问题，并发资源竞争问题等。为了发现这类问题，需要在测试时在一定时间内，对于系统持续施加一定的负载。这种类型的测试包括负载测试和压力测试。

负载测试和压力测试的区别在于施加的压力，以及期望达到的目标。负载测试会对系统施加期望的正常压力，以及预期的压力峰值，以此来确认系统能够在正常压力下提供稳定的服务，并且能够承受可预期的压力峰值。而压力测试则会向系统施加尽可能大的压力，以此来确认系统能够承受的压力的极限。

对于负载测试和压力测试来说，除了足够的系统负载，测试持续的时间是否足够，也是影响测试结果可靠性的重要因素，但对于时长的选择以及相应的风险的定量评估需要进一点研究。

注意，评估压力测试和负载测试的另一个关键因素是系统性能，比如计算性能、内存、储存和网络性能等。尤其对于压力测试，不同平台配置组合的测试数据的汇总才能算是完整有效的。

静态白盒测试
============

静态白盒测试就是在不实际运行系统的情况下，检查技术设计、构架和代码实现的过程。

由于并不需要实际运行系统，所以静态白盒测试可以在技术设计和开发的早期就开始，这样就可以极大的提早对于系统实现的验证。而越早发现和修复Bug，那么所需要的成本就越低，因而有效的静态白盒测试可以很好的提高发现系统问题的效率、改善系统质量。

同样，作为提供了尽早开始系统技术实现质量保障手段的静态白盒测试，为了充分保障其有效性，也必须尽可能早的开始执行。由于直到系统最终发布，系统的技术实现都是在一直演进的，所以静态白盒测试也应当是贯穿整个项目过程的。如果只是在系统基本开发完成后才开始静态白盒测试，由于问题积累所导致的极大的修复成本，以及项目后期相对不足的时间资源，往往导致这个时候发生的问题没有办法修复。

静态白盒测试可以人工完成，也可以使用工具。人工操作需要QA人员有相当高的开发技术能力，开发人员也往往会参与到这个测试过程中。人工静态白盒测试的极致就是结对编程，也就是在开发时进行完全同步的静态白盒测试。由于对于QA人员的技术要求很高，同时在测试过程中需要沟通和确认大量的实现细节，所以人工测试往往被认为是低效费比的。然而，也由于同样的原因，人工测试对于QA工程师的技术能力的积累和提高，以及对于系统技术细节的审核和质量保障，都是有极大的帮助的。现在市面也有很多静态代码检查工具，可以用来协助进行自动化的静态白盒测试。由于这类工具不能理解代码的业务语义和上下文，所以往往只能用来检查基本的代码格式以及非常初级的设计实现问题。静态代码工具虽然有明显的缺陷，但可以极大的提高静态白盒测试的效率，将QA工程师从大量基本的代码细节审核中解放出来，更专注于代码的结构和语义问题。

代码评审(code review)
---------------------

代码评审是静态白盒测试的主要手段，根据其形式和目标，可以分为以下几种。

同行审查(peer review)
`````````````````````

两个团队成员之间非相互的代码评审。可以是两个开发成员之间进行，也可以是开发和QA之间。如果团队规模很小，也可以整个团队的。同行评审应当是频繁进行的，比如每次需要提交代码修改到版本库的时候。具体形式可以是正式的，也可以是非正式的。

代码走查(walkthrough)
`````````````````````

比同行审查更加正式的是代码写查。当系统开发到一定阶段，比如一个小的milestone、单个功能或者模块被完成的时候，相关的开发和QA共同进行的代码审查。代码走查需要对于所有的代码进行评审，所以为了保证效率，应当在进行评审会议前，将需要评审的代码和实现原理的解释描述文档发送给所有的参与人员，搜集意见和问题。最终的评审会议集中讨论搜集到的问题，以及解决方案和后续跟进。

代码审查(inspection)
```````````````````

代码审查是最终也是最正式的代码评审，所以一般需要评审的范围也会比较完整。通常，会指派多人，分别针对不同的部分从不同的角度进行评审。所有的产出物，包括代码、所有的设计、构架和实现文档都会应当被包括进来。

代码规范
````````

代码规范是开发人员在进行代码编写时必须遵守的标准。通常代码规范主要内容是代码的风格要求。往往代码规范也会包含一些非强制性的建议和指导。

代码规范要达到的最重要的一个目标就是提高代码的可读性，因为可读性是代码可维护的基础。

行业里有很多现成的代码规范可以参考和使用。不同规范之间往往也不存在对与错，可以根据团队现有的习惯挑选和自定义。制定执行规范重要的是一致性、明确性和强制性。

代码规范往往可以通过静态代码检查工具来实现自动化的检查。

动态白盒测试
============

动态白盒测试是针对代码的技术实现方式进行设计和调整，需要在系统部分或者整体运行的情况下执行的测试。动态白盒测试的校验手段也可以从最表层的系统行为，深入对到系统内部代码的运行状态的检测。

单元测试(Unit Testing)，集成测试(Integration Testing)，系统测试(System Testing)
-----------------------------------------------------------------------------

单元测试是针对系统实现的最小独立单元进行的测试，这个单元可以是一个函数或者方法，也可以是一个类或者模块。系统测试是指将系统的所有模块都组织起来进行的测试。集成测试则是介于单元测试和系统测试之间的，包含系统的一部分相互依赖的模块。

由于实际上相当部分模块都会依赖其他低层模块进行测试，所以很多单元测试也同时可以认为是集成测试，两者之间并没有十分明确的界线。

对于单元测试和集成测试，由于需要执行部分模块的代码，而这些模块自身往往不提供独立运行的能力，所以需要专门的测试套件来提供运行环境。另外，这些模块的运行结果往往也不提供任何形式的UI，如GUI或者CLI，让测试人员可以人工的校验代码运行结果，所以也往往需要在测试套件里实现专门的测试代码来进行校验工作。综上，单元测试和集成测试都是需要通过测试代码实现的，所以往往都可以转为自动化的。在有完整的自动化集成测试的情况下，作为集成测试向上的终极形式的系统测试，其自动化也是水到渠成的。
 
程序 = 数据 + 算法

所以，对于动态白盒测试来说，需要关注的也就是系统的数据和算法的载体，也就是代码。

数据覆盖
---------

数据流(Data Flow)
``````````````````

一般来说黑盒和灰盒测试，测试关注的是系统或者模块的最终输入和输出数据，而白盒测试可以实现对于系统内部数据中间状态的检测。这种可能性给了测试人员对于系统状态更细粒度的校验的手段。不过使用这种方法也会使得测试用例与技术实现细节紧密耦合，而实现细节是会经常变化的，这会使得测试用例的重用性大大下降，而维护成本极大提高。所以一般情况下不会使用这种方法来检验系统状态，而是通过模块的公共接口进行数据校验。

子边界(Sub-Boundary)
``````````````````````

子边界是在业务边界内部，由于技术实现限制所产生的内部边界。对于黑盒测试来说，子边界一般是透明的。具体讨论见上文。

公式和等式
``````````

系统业务有时会需要或者部分需要一些计算公式，这些计算公式的代码实现往往会影响子边界、计算精度等方面，也有可能会出现一些异常问题，比如将0将为除数。所以，如果有明确的计算公式，需要同时从业务和技术角度进行分析，设计测试用例。

强制出错(Error Forcing)
``````````````````````

系统运行时会产生和遇到很多异常。这些异常通常有两大类，一类是业务异常，如不符合法的输入或者状态，另一类是系统依赖的低层资源或者硬件故障造成的系统异常，如网络异常，文件读写异常等。对于可预期的异常的处理逻辑应当是包含在产品规格说明中的。同样，测试也应该包含对于异常情况的处理。而由于很多异常情况的触发，尤其是系统异常，通过正常的输入和操作是做不到的。这时，就需要从代码实现角度分析异常产生的场景，通过测试套件工件来模拟异常的发生。

代码覆盖
----------

对于测试用例的覆盖情况的定量评估的一个重要手段就是对于系统代码的覆盖率的评估。也就是评估在测试阶段，有多少代码被执行。但是需要注意的是，代码覆盖率不能等同于测试完整率，比如由于技术设计和实现的疏漏而导致个别功能完全没有实现时，就算所有的代码在测试时都被执行过，测试仍然是不完整的。#TODO 测试完整率的评估？

在实际测试中，考虑到测试成本，代码覆盖不可能达到100%，尤其是异常的处理逻辑。一般来说，能够达到80%就是相当优秀的了。

代码语句覆盖(Statement Coverage)，代码行覆盖(Line Coverage)
`````````````````````````````````````````````````````````

评估代码覆盖最简单的方式就是代码语句或者代码行覆盖，也就是执行过的程序代码语句数或者行数除以总代码语句数或者行数，得到的比率。

由于实际测试时覆盖率达不到100%，对于测试结果的风险评估或者改进测试方案需要从业务角度给出更细粒度的信息，比如哪些业务逻辑分支没有被测试到，而这些信息是代码语句或者行覆盖无法给出的。而且，所有的代码语句被覆盖并不代表所有的业务逻辑都被覆盖了。

分支覆盖(Branch Coverage)
```````````````````````````

分支覆盖是分析代码逻辑分支路径的覆盖情况。这种覆盖数据对于代码中有隐示分支路径的情况，有更加准确的评估。

条件覆盖(condition coverage)
`````````````````````````````

分支覆盖更进一步则是条件覆盖。对于某个分支的判断条件，涉及多个条件的组合的时候，同一路径被执行一次并不能说明所有的业务场景都被覆盖到了。条件覆盖就是要对于所有条件组合情况的覆盖进行评估。

.. todo::

    - 硬件配置测试

    - 软件兼容性测试

    - 国际化测试

    - 可用性测试

    - 文档测试

    - 安全性测试

    - 自动化测试

        - 测试工具

            - 查看器(view)和监视器(monitor)

            - 驱动器(driver)

            - 桩(stub)

            - 压力工具(stress tool)，负载工具(stress tool)

            - 干扰注射器(interference injector)，噪声生成器(noise generator)

            - 分析工具

        - 测试自动化

        - 随机测试(random testing)

            - 傻猴子(dumb monkey)

            - 半聪明猴子(semi-smart monkey)

            - 聪明猴子(smart monkey)
